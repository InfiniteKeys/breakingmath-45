// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://woosegomxvbgzelyqvoj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Indvb3NlZ29teHZiZ3plbHlxdm9qIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg2Nzg3OTAsImV4cCI6MjA3NDI1NDc5MH0.htpKQLRZjqwochLN7MBVI8tA5F-AAwktDd5SLq6vUSc";

// Force HTTP/1.1 fetch for restricted networks that block QUIC/HTTP3
const forceHTTP1Fetch = async (url: RequestInfo | URL, options: RequestInit = {}): Promise<Response> => {
  const urlObj = new URL(url.toString());
  
  // Force API key in URL params for max compatibility
  urlObj.searchParams.set('apikey', SUPABASE_PUBLISHABLE_KEY);
  
  // Minimal headers to avoid network filtering
  const basicHeaders: Record<string, string> = {
    'apikey': SUPABASE_PUBLISHABLE_KEY,
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    // Force HTTP/1.1 by setting Connection header
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
  };
  
  // Add existing headers but filter problematic ones
  if (options.headers) {
    const existingHeaders = new Headers(options.headers);
    existingHeaders.forEach((value, key) => {
      const lowerKey = key.toLowerCase();
      if (!['user-agent', 'referer', 'origin', 'sec-fetch-site', 'sec-fetch-mode'].includes(lowerKey)) {
        basicHeaders[key] = value;
      }
    });
  }
  
  const requestOptions: RequestInit = {
    ...options,
    headers: basicHeaders,
    mode: 'cors',
    cache: 'no-cache',
    credentials: 'omit',
    // Force traditional fetch behavior
    redirect: 'follow',
    referrerPolicy: 'no-referrer-when-downgrade',
  };
  
  try {
    // Try direct fetch first
    const response = await fetch(urlObj.toString(), requestOptions);
    
    if (!response.ok && response.status === 0) {
      throw new Error('CORS or network blocked');
    }
    
    return response;
  } catch (error) {
    console.warn('Direct Supabase request failed, trying proxy fallback:', error);
    
    // If direct request fails, try proxy fallback for critical endpoints
    if (urlObj.pathname.includes('/rest/v1/')) {
      try {
        return await tryProxyFallback(url, options);
      } catch (proxyError) {
        console.error('Proxy fallback also failed:', proxyError);
        throw error; // Throw original error
      }
    }
    
    throw error;
  }
};

// Proxy fallback for critical REST API calls
const tryProxyFallback = async (url: RequestInfo | URL, options: RequestInit = {}): Promise<Response> => {
  const urlObj = new URL(url.toString());
  
  // Use our edge function as a proxy
  const proxyUrl = `${SUPABASE_URL}/functions/v1/api-proxy`;
  
  const proxyRequest = {
    method: options.method || 'GET',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
    },
    body: JSON.stringify({
      endpoint: urlObj.pathname + urlObj.search,
      method: options.method || 'GET',
      body: options.body,
      headers: Object.fromEntries(new Headers(options.headers || {})),
    }),
  };
  
  return fetch(proxyUrl, proxyRequest);
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  global: {
    fetch: forceHTTP1Fetch,
  },
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    // Add these to help with restricted networks
    detectSessionInUrl: false,
    flowType: 'implicit',
  },
  db: {
    schema: 'public',
  },
  realtime: {
    params: {
      eventsPerSecond: 2, // Reduce realtime load
    },
  },
});